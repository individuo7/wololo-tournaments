/// <reference path="./custom.d.ts" />
// tslint:disable
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version:
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url';
import * as portableFetch from 'portable-fetch';
import { Configuration } from './configuration';

let BASE_PATH = 'http://localhost:8000';

if (process.env.NODE_ENV === 'production') {
  BASE_PATH = 'https://wololo.appjango.com';
}
/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|'
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration!: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name!: 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface Data
 */
export interface Data {
  /**
   *
   * @type {string}
   * @memberof Data
   */
  name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Data
   */
  members: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof Data
   */
  _public?: boolean;
}

/**
 *
 * @export
 * @interface Data1
 */
export interface Data1 {
  /**
   *
   * @type {string}
   * @memberof Data1
   */
  name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Data1
   */
  members: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof Data1
   */
  _public?: boolean;
}

/**
 *
 * @export
 * @interface Data2
 */
export interface Data2 {
  /**
   *
   * @type {string}
   * @memberof Data2
   */
  name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Data2
   */
  members?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof Data2
   */
  _public?: boolean;
}

/**
 *
 * @export
 * @interface Data3
 */
export interface Data3 {
  /**
   *
   * @type {number}
   * @memberof Data3
   */
  user: number;
  /**
   *
   * @type {number}
   * @memberof Data3
   */
  game: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Data3
   */
  scores: Array<string>;
}

/**
 *
 * @export
 * @interface Data4
 */
export interface Data4 {
  /**
   *
   * @type {number}
   * @memberof Data4
   */
  user: number;
  /**
   *
   * @type {number}
   * @memberof Data4
   */
  game: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Data4
   */
  scores: Array<string>;
}

/**
 *
 * @export
 * @interface Data5
 */
export interface Data5 {
  /**
   *
   * @type {number}
   * @memberof Data5
   */
  user?: number;
  /**
   *
   * @type {number}
   * @memberof Data5
   */
  game?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Data5
   */
  scores?: Array<string>;
}

/**
 * ApiApi - fetch parameter creator
 * @export
 */
export const ApiApiFetchParamCreator = function(_configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gamesList(tournament: string, options: any = {}): FetchArgs {
      // verify required parameter 'tournament' is not null or undefined
      if (tournament === null || tournament === undefined) {
        throw new RequiredError(
          'tournament',
          'Required parameter tournament was null or undefined when calling gamesList.'
        );
      }
      const localVarPath = `/api/games/t/{tournament}/`.replace(
        `{${'tournament'}}`,
        encodeURIComponent(String(tournament))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gamesRead(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling gamesRead.'
        );
      }
      const localVarPath = `/api/games/{slug}/`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {Data} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsCreate(data?: Data, options: any = {}): FetchArgs {
      const localVarPath = `/api/groups/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsDelete(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling groupsDelete.'
        );
      }
      const localVarPath = `/api/groups/{slug}/`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsList(options: any = {}): FetchArgs {
      const localVarPath = `/api/groups/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} slug
     * @param {Data2} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsPartialUpdate(slug: string, data?: Data2, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling groupsPartialUpdate.'
        );
      }
      const localVarPath = `/api/groups/{slug}/`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data2' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsRead(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling groupsRead.'
        );
      }
      const localVarPath = `/api/groups/{slug}/`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} slug
     * @param {Data1} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsUpdate(slug: string, data?: Data1, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling groupsUpdate.'
        );
      }
      const localVarPath = `/api/groups/{slug}/`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data1' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardsList(options: any = {}): FetchArgs {
      const localVarPath = `/api/leaderboards/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardsList0(tournament: string, options: any = {}): FetchArgs {
      // verify required parameter 'tournament' is not null or undefined
      if (tournament === null || tournament === undefined) {
        throw new RequiredError(
          'tournament',
          'Required parameter tournament was null or undefined when calling leaderboardsList0.'
        );
      }
      const localVarPath = `/api/leaderboards/{tournament}/`.replace(
        `{${'tournament'}}`,
        encodeURIComponent(String(tournament))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {Data3} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsCreate(data?: Data3, options: any = {}): FetchArgs {
      const localVarPath = `/api/predictions/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data3' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsDelete(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling predictionsDelete.'
        );
      }
      const localVarPath = `/api/predictions/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsList(options: any = {}): FetchArgs {
      const localVarPath = `/api/predictions/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {Data5} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsPartialUpdate(id: number, data?: Data5, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling predictionsPartialUpdate.'
        );
      }
      const localVarPath = `/api/predictions/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data5' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsRead(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling predictionsRead.'
        );
      }
      const localVarPath = `/api/predictions/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {Data4} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsUpdate(id: number, data?: Data4, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling predictionsUpdate.'
        );
      }
      const localVarPath = `/api/predictions/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data4' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tournamentsList(options: any = {}): FetchArgs {
      const localVarPath = `/api/tournaments/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tournamentsRead(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling tournamentsRead.'
        );
      }
      const localVarPath = `/api/tournaments/{slug}/`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gamesList(
      tournament: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).gamesList(
        tournament,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gamesRead(
      slug: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).gamesRead(slug, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {Data} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsCreate(
      data?: Data,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).groupsCreate(data, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsDelete(
      slug: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).groupsDelete(slug, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).groupsList(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} slug
     * @param {Data2} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsPartialUpdate(
      slug: string,
      data?: Data2,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).groupsPartialUpdate(
        slug,
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsRead(
      slug: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).groupsRead(slug, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} slug
     * @param {Data1} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsUpdate(
      slug: string,
      data?: Data1,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).groupsUpdate(
        slug,
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardsList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).leaderboardsList(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardsList0(
      tournament: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).leaderboardsList0(
        tournament,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {Data3} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsCreate(
      data?: Data3,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).predictionsCreate(
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsDelete(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).predictionsDelete(
        id,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).predictionsList(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {Data5} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsPartialUpdate(
      id: number,
      data?: Data5,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).predictionsPartialUpdate(
        id,
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsRead(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).predictionsRead(id, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {Data4} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsUpdate(
      id: number,
      data?: Data4,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).predictionsUpdate(
        id,
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tournamentsList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).tournamentsList(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tournamentsRead(
      slug: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).tournamentsRead(
        slug,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {string} tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gamesList(tournament: string, options?: any) {
      return ApiApiFp(configuration).gamesList(tournament, options)(fetch, basePath);
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gamesRead(slug: string, options?: any) {
      return ApiApiFp(configuration).gamesRead(slug, options)(fetch, basePath);
    },
    /**
     *
     * @param {Data} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsCreate(data?: Data, options?: any) {
      return ApiApiFp(configuration).groupsCreate(data, options)(fetch, basePath);
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsDelete(slug: string, options?: any) {
      return ApiApiFp(configuration).groupsDelete(slug, options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsList(options?: any) {
      return ApiApiFp(configuration).groupsList(options)(fetch, basePath);
    },
    /**
     *
     * @param {string} slug
     * @param {Data2} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsPartialUpdate(slug: string, data?: Data2, options?: any) {
      return ApiApiFp(configuration).groupsPartialUpdate(slug, data, options)(fetch, basePath);
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsRead(slug: string, options?: any) {
      return ApiApiFp(configuration).groupsRead(slug, options)(fetch, basePath);
    },
    /**
     *
     * @param {string} slug
     * @param {Data1} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsUpdate(slug: string, data?: Data1, options?: any) {
      return ApiApiFp(configuration).groupsUpdate(slug, data, options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardsList(options?: any) {
      return ApiApiFp(configuration).leaderboardsList(options)(fetch, basePath);
    },
    /**
     *
     * @param {string} tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardsList0(tournament: string, options?: any) {
      return ApiApiFp(configuration).leaderboardsList0(tournament, options)(fetch, basePath);
    },
    /**
     *
     * @param {Data3} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsCreate(data?: Data3, options?: any) {
      return ApiApiFp(configuration).predictionsCreate(data, options)(fetch, basePath);
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsDelete(id: number, options?: any) {
      return ApiApiFp(configuration).predictionsDelete(id, options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsList(options?: any) {
      return ApiApiFp(configuration).predictionsList(options)(fetch, basePath);
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {Data5} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsPartialUpdate(id: number, data?: Data5, options?: any) {
      return ApiApiFp(configuration).predictionsPartialUpdate(id, data, options)(fetch, basePath);
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsRead(id: number, options?: any) {
      return ApiApiFp(configuration).predictionsRead(id, options)(fetch, basePath);
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {Data4} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsUpdate(id: number, data?: Data4, options?: any) {
      return ApiApiFp(configuration).predictionsUpdate(id, data, options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tournamentsList(options?: any) {
      return ApiApiFp(configuration).tournamentsList(options)(fetch, basePath);
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tournamentsRead(slug: string, options?: any) {
      return ApiApiFp(configuration).tournamentsRead(slug, options)(fetch, basePath);
    }
  };
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
  /**
   *
   * @param {string} tournament
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public gamesList(tournament: string, options?: any) {
    return ApiApiFp(this.configuration).gamesList(tournament, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} slug
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public gamesRead(slug: string, options?: any) {
    return ApiApiFp(this.configuration).gamesRead(slug, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {Data} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public groupsCreate(data?: Data, options?: any) {
    return ApiApiFp(this.configuration).groupsCreate(data, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} slug
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public groupsDelete(slug: string, options?: any) {
    return ApiApiFp(this.configuration).groupsDelete(slug, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public groupsList(options?: any) {
    return ApiApiFp(this.configuration).groupsList(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} slug
   * @param {Data2} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public groupsPartialUpdate(slug: string, data?: Data2, options?: any) {
    return ApiApiFp(this.configuration).groupsPartialUpdate(slug, data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {string} slug
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public groupsRead(slug: string, options?: any) {
    return ApiApiFp(this.configuration).groupsRead(slug, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} slug
   * @param {Data1} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public groupsUpdate(slug: string, data?: Data1, options?: any) {
    return ApiApiFp(this.configuration).groupsUpdate(slug, data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public leaderboardsList(options?: any) {
    return ApiApiFp(this.configuration).leaderboardsList(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} tournament
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public leaderboardsList0(tournament: string, options?: any) {
    return ApiApiFp(this.configuration).leaderboardsList0(tournament, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {Data3} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public predictionsCreate(data?: Data3, options?: any) {
    return ApiApiFp(this.configuration).predictionsCreate(data, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {number} id A unique integer value identifying this prediction.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public predictionsDelete(id: number, options?: any) {
    return ApiApiFp(this.configuration).predictionsDelete(id, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public predictionsList(options?: any) {
    return ApiApiFp(this.configuration).predictionsList(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {number} id A unique integer value identifying this prediction.
   * @param {Data5} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public predictionsPartialUpdate(id: number, data?: Data5, options?: any) {
    return ApiApiFp(this.configuration).predictionsPartialUpdate(id, data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {number} id A unique integer value identifying this prediction.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public predictionsRead(id: number, options?: any) {
    return ApiApiFp(this.configuration).predictionsRead(id, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {number} id A unique integer value identifying this prediction.
   * @param {Data4} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public predictionsUpdate(id: number, data?: Data4, options?: any) {
    return ApiApiFp(this.configuration).predictionsUpdate(id, data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public tournamentsList(options?: any) {
    return ApiApiFp(this.configuration).tournamentsList(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} slug
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public tournamentsRead(slug: string, options?: any) {
    return ApiApiFp(this.configuration).tournamentsRead(slug, options)(this.fetch, this.basePath);
  }
}

/**
 * DocsApi - fetch parameter creator
 * @export
 */
export const DocsApiFetchParamCreator = function(_configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(options: any = {}): FetchArgs {
      const localVarPath = `/docs/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * DocsApi - functional programming interface
 * @export
 */
export const DocsApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DocsApiFetchParamCreator(configuration).list(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * DocsApi - factory interface
 * @export
 */
export const DocsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(options?: any) {
      return DocsApiFp(configuration).list(options)(fetch, basePath);
    }
  };
};

/**
 * DocsApi - object-oriented interface
 * @export
 * @class DocsApi
 * @extends {BaseAPI}
 */
export class DocsApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocsApi
   */
  public list(options?: any) {
    return DocsApiFp(this.configuration).list(options)(this.fetch, this.basePath);
  }
}
