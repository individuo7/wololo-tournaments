/// <reference path="./custom.d.ts" />
// tslint:disable
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version:
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url';
import * as portableFetch from 'portable-fetch';
import { Configuration } from './configuration';

let BASE_PATH = 'http://localhost:8000';

if (process.env.NODE_ENV === 'production') {
  BASE_PATH = 'https://wololo.appjango.com';
}

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|'
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  // @ts-ignore
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  // @ts-ignore
  name: 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface Data
 */
export interface Data {
  /**
   *
   * @type {string}
   * @memberof Data
   */
  name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Data
   */
  members: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof Data
   */
  _public?: boolean;
}

/**
 *
 * @export
 * @interface Data1
 */
export interface Data1 {
  /**
   *
   * @type {string}
   * @memberof Data1
   */
  name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Data1
   */
  members: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof Data1
   */
  _public?: boolean;
}

/**
 *
 * @export
 * @interface Data10
 */
export interface Data10 {
  /**
   *
   * @type {string}
   * @memberof Data10
   */
  newPassword1: string;
  /**
   *
   * @type {string}
   * @memberof Data10
   */
  newPassword2: string;
}

/**
 *
 * @export
 * @interface Data11
 */
export interface Data11 {
  /**
   *
   * @type {string}
   * @memberof Data11
   */
  email: string;
}

/**
 *
 * @export
 * @interface Data12
 */
export interface Data12 {
  /**
   *
   * @type {string}
   * @memberof Data12
   */
  newPassword1: string;
  /**
   *
   * @type {string}
   * @memberof Data12
   */
  newPassword2: string;
  /**
   *
   * @type {string}
   * @memberof Data12
   */
  uid: string;
  /**
   *
   * @type {string}
   * @memberof Data12
   */
  token: string;
}

/**
 *
 * @export
 * @interface Data13
 */
export interface Data13 {
  /**
   *
   * @type {string}
   * @memberof Data13
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Data13
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof Data13
   */
  password1: string;
  /**
   *
   * @type {string}
   * @memberof Data13
   */
  password2: string;
}

/**
 *
 * @export
 * @interface Data14
 */
export interface Data14 {
  /**
   *
   * @type {string}
   * @memberof Data14
   */
  key: string;
}

/**
 *
 * @export
 * @interface Data15
 */
export interface Data15 {
  /**
   * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
   * @type {string}
   * @memberof Data15
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Data15
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof Data15
   */
  lastName?: string;
}

/**
 *
 * @export
 * @interface Data16
 */
export interface Data16 {
  /**
   * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
   * @type {string}
   * @memberof Data16
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof Data16
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof Data16
   */
  lastName?: string;
}

/**
 *
 * @export
 * @interface Data2
 */
export interface Data2 {
  /**
   *
   * @type {string}
   * @memberof Data2
   */
  name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Data2
   */
  members?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof Data2
   */
  _public?: boolean;
}

/**
 *
 * @export
 * @interface Data3
 */
export interface Data3 {
  /**
   *
   * @type {number}
   * @memberof Data3
   */
  user: number;
  /**
   *
   * @type {number}
   * @memberof Data3
   */
  game: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Data3
   */
  scores: Array<string>;
}

/**
 *
 * @export
 * @interface Data4
 */
export interface Data4 {
  /**
   *
   * @type {number}
   * @memberof Data4
   */
  user: number;
  /**
   *
   * @type {number}
   * @memberof Data4
   */
  game: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Data4
   */
  scores: Array<string>;
}

/**
 *
 * @export
 * @interface Data5
 */
export interface Data5 {
  /**
   *
   * @type {number}
   * @memberof Data5
   */
  user?: number;
  /**
   *
   * @type {number}
   * @memberof Data5
   */
  game?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Data5
   */
  scores?: Array<string>;
}

/**
 *
 * @export
 * @interface Data6
 */
export interface Data6 {
  /**
   * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
   * @type {string}
   * @memberof Data6
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Data6
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof Data6
   */
  icon?: string;
  /**
   *
   * @type {string}
   * @memberof Data6
   */
  backgroundColor?: string;
  /**
   *
   * @type {string}
   * @memberof Data6
   */
  dateJoined?: string;
  /**
   * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
   * @type {boolean}
   * @memberof Data6
   */
  isActive?: boolean;
  /**
   *
   * @type {string}
   * @memberof Data6
   */
  lastLogin?: string;
}

/**
 *
 * @export
 * @interface Data7
 */
export interface Data7 {
  /**
   * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
   * @type {string}
   * @memberof Data7
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Data7
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof Data7
   */
  icon?: string;
  /**
   *
   * @type {string}
   * @memberof Data7
   */
  backgroundColor?: string;
  /**
   *
   * @type {string}
   * @memberof Data7
   */
  dateJoined?: string;
  /**
   * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
   * @type {boolean}
   * @memberof Data7
   */
  isActive?: boolean;
  /**
   *
   * @type {string}
   * @memberof Data7
   */
  lastLogin?: string;
}

/**
 *
 * @export
 * @interface Data8
 */
export interface Data8 {
  /**
   * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
   * @type {string}
   * @memberof Data8
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof Data8
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof Data8
   */
  icon?: string;
  /**
   *
   * @type {string}
   * @memberof Data8
   */
  backgroundColor?: string;
  /**
   *
   * @type {string}
   * @memberof Data8
   */
  dateJoined?: string;
  /**
   * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
   * @type {boolean}
   * @memberof Data8
   */
  isActive?: boolean;
  /**
   *
   * @type {string}
   * @memberof Data8
   */
  lastLogin?: string;
}

/**
 *
 * @export
 * @interface Data9
 */
export interface Data9 {
  /**
   *
   * @type {string}
   * @memberof Data9
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof Data9
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof Data9
   */
  password: string;
}

/**
 * ApiApi - fetch parameter creator
 * @export
 */
// @ts-ignore
export const ApiApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gamesRead(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling gamesRead.'
        );
      }
      const localVarPath = `/api/games/{slug}/`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gamesTList(tournament: string, options: any = {}): FetchArgs {
      // verify required parameter 'tournament' is not null or undefined
      if (tournament === null || tournament === undefined) {
        throw new RequiredError(
          'tournament',
          'Required parameter tournament was null or undefined when calling gamesTList.'
        );
      }
      const localVarPath = `/api/games/t/{tournament}/`.replace(
        `{${'tournament'}}`,
        encodeURIComponent(String(tournament))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {Data} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsCreate(data?: Data, options: any = {}): FetchArgs {
      const localVarPath = `/api/groups/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsDelete(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling groupsDelete.'
        );
      }
      const localVarPath = `/api/groups/{slug}/`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsList(options: any = {}): FetchArgs {
      const localVarPath = `/api/groups/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} slug
     * @param {Data2} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsPartialUpdate(slug: string, data?: Data2, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling groupsPartialUpdate.'
        );
      }
      const localVarPath = `/api/groups/{slug}/`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data2' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsRead(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling groupsRead.'
        );
      }
      const localVarPath = `/api/groups/{slug}/`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} slug
     * @param {Data1} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsUpdate(slug: string, data?: Data1, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling groupsUpdate.'
        );
      }
      const localVarPath = `/api/groups/{slug}/`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data1' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardsList(options: any = {}): FetchArgs {
      const localVarPath = `/api/leaderboards/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardsList0(tournament: string, options: any = {}): FetchArgs {
      // verify required parameter 'tournament' is not null or undefined
      if (tournament === null || tournament === undefined) {
        throw new RequiredError(
          'tournament',
          'Required parameter tournament was null or undefined when calling leaderboardsList0.'
        );
      }
      const localVarPath = `/api/leaderboards/{tournament}/`.replace(
        `{${'tournament'}}`,
        encodeURIComponent(String(tournament))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {Data3} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsCreate(data?: Data3, options: any = {}): FetchArgs {
      const localVarPath = `/api/predictions/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data3' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsDelete(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling predictionsDelete.'
        );
      }
      const localVarPath = `/api/predictions/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsList(options: any = {}): FetchArgs {
      const localVarPath = `/api/predictions/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {Data5} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsPartialUpdate(id: number, data?: Data5, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling predictionsPartialUpdate.'
        );
      }
      const localVarPath = `/api/predictions/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data5' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsRead(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling predictionsRead.'
        );
      }
      const localVarPath = `/api/predictions/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {Data4} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsUpdate(id: number, data?: Data4, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling predictionsUpdate.'
        );
      }
      const localVarPath = `/api/predictions/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data4' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tournamentsList(options: any = {}): FetchArgs {
      const localVarPath = `/api/tournaments/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tournamentsRead(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling tournamentsRead.'
        );
      }
      const localVarPath = `/api/tournaments/{slug}/`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {Data6} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersCreate(data?: Data6, options: any = {}): FetchArgs {
      const localVarPath = `/api/users/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data6' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersDelete(username: string, options: any = {}): FetchArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling usersDelete.'
        );
      }
      const localVarPath = `/api/users/{username}/`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersList(options: any = {}): FetchArgs {
      const localVarPath = `/api/users/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMe(options: any = {}): FetchArgs {
      const localVarPath = `/api/users/me/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} username
     * @param {Data8} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPartialUpdate(username: string, data?: Data8, options: any = {}): FetchArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling usersPartialUpdate.'
        );
      }
      const localVarPath = `/api/users/{username}/`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data8' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersRead(username: string, options: any = {}): FetchArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling usersRead.'
        );
      }
      const localVarPath = `/api/users/{username}/`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} username
     * @param {Data7} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersUpdate(username: string, data?: Data7, options: any = {}): FetchArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling usersUpdate.'
        );
      }
      const localVarPath = `/api/users/{username}/`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data7' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gamesRead(
      slug: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).gamesRead(slug, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gamesTList(
      tournament: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).gamesTList(
        tournament,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {Data} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsCreate(
      data?: Data,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).groupsCreate(data, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsDelete(
      slug: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).groupsDelete(slug, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).groupsList(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} slug
     * @param {Data2} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsPartialUpdate(
      slug: string,
      data?: Data2,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).groupsPartialUpdate(
        slug,
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsRead(
      slug: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).groupsRead(slug, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} slug
     * @param {Data1} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsUpdate(
      slug: string,
      data?: Data1,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).groupsUpdate(
        slug,
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardsList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).leaderboardsList(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardsList0(
      tournament: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).leaderboardsList0(
        tournament,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {Data3} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsCreate(
      data?: Data3,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).predictionsCreate(
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsDelete(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).predictionsDelete(
        id,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).predictionsList(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {Data5} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsPartialUpdate(
      id: number,
      data?: Data5,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).predictionsPartialUpdate(
        id,
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsRead(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).predictionsRead(id, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {Data4} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsUpdate(
      id: number,
      data?: Data4,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).predictionsUpdate(
        id,
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tournamentsList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).tournamentsList(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tournamentsRead(
      slug: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).tournamentsRead(
        slug,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {Data6} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersCreate(
      data?: Data6,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).usersCreate(data, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersDelete(
      username: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).usersDelete(
        username,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).usersList(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMe(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).usersMe(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} username
     * @param {Data8} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPartialUpdate(
      username: string,
      data?: Data8,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).usersPartialUpdate(
        username,
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersRead(
      username: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).usersRead(username, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} username
     * @param {Data7} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersUpdate(
      username: string,
      data?: Data7,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ApiApiFetchParamCreator(configuration).usersUpdate(
        username,
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gamesRead(slug: string, options?: any) {
      return ApiApiFp(configuration).gamesRead(slug, options)(fetch, basePath);
    },
    /**
     *
     * @param {string} tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gamesTList(tournament: string, options?: any) {
      return ApiApiFp(configuration).gamesTList(tournament, options)(fetch, basePath);
    },
    /**
     *
     * @param {Data} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsCreate(data?: Data, options?: any) {
      return ApiApiFp(configuration).groupsCreate(data, options)(fetch, basePath);
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsDelete(slug: string, options?: any) {
      return ApiApiFp(configuration).groupsDelete(slug, options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsList(options?: any) {
      return ApiApiFp(configuration).groupsList(options)(fetch, basePath);
    },
    /**
     *
     * @param {string} slug
     * @param {Data2} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsPartialUpdate(slug: string, data?: Data2, options?: any) {
      return ApiApiFp(configuration).groupsPartialUpdate(slug, data, options)(fetch, basePath);
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsRead(slug: string, options?: any) {
      return ApiApiFp(configuration).groupsRead(slug, options)(fetch, basePath);
    },
    /**
     *
     * @param {string} slug
     * @param {Data1} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsUpdate(slug: string, data?: Data1, options?: any) {
      return ApiApiFp(configuration).groupsUpdate(slug, data, options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardsList(options?: any) {
      return ApiApiFp(configuration).leaderboardsList(options)(fetch, basePath);
    },
    /**
     *
     * @param {string} tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardsList0(tournament: string, options?: any) {
      return ApiApiFp(configuration).leaderboardsList0(tournament, options)(fetch, basePath);
    },
    /**
     *
     * @param {Data3} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsCreate(data?: Data3, options?: any) {
      return ApiApiFp(configuration).predictionsCreate(data, options)(fetch, basePath);
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsDelete(id: number, options?: any) {
      return ApiApiFp(configuration).predictionsDelete(id, options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsList(options?: any) {
      return ApiApiFp(configuration).predictionsList(options)(fetch, basePath);
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {Data5} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsPartialUpdate(id: number, data?: Data5, options?: any) {
      return ApiApiFp(configuration).predictionsPartialUpdate(id, data, options)(fetch, basePath);
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsRead(id: number, options?: any) {
      return ApiApiFp(configuration).predictionsRead(id, options)(fetch, basePath);
    },
    /**
     *
     * @param {number} id A unique integer value identifying this prediction.
     * @param {Data4} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    predictionsUpdate(id: number, data?: Data4, options?: any) {
      return ApiApiFp(configuration).predictionsUpdate(id, data, options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tournamentsList(options?: any) {
      return ApiApiFp(configuration).tournamentsList(options)(fetch, basePath);
    },
    /**
     *
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tournamentsRead(slug: string, options?: any) {
      return ApiApiFp(configuration).tournamentsRead(slug, options)(fetch, basePath);
    },
    /**
     *
     * @param {Data6} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersCreate(data?: Data6, options?: any) {
      return ApiApiFp(configuration).usersCreate(data, options)(fetch, basePath);
    },
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersDelete(username: string, options?: any) {
      return ApiApiFp(configuration).usersDelete(username, options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersList(options?: any) {
      return ApiApiFp(configuration).usersList(options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMe(options?: any) {
      return ApiApiFp(configuration).usersMe(options)(fetch, basePath);
    },
    /**
     *
     * @param {string} username
     * @param {Data8} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPartialUpdate(username: string, data?: Data8, options?: any) {
      return ApiApiFp(configuration).usersPartialUpdate(username, data, options)(fetch, basePath);
    },
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersRead(username: string, options?: any) {
      return ApiApiFp(configuration).usersRead(username, options)(fetch, basePath);
    },
    /**
     *
     * @param {string} username
     * @param {Data7} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersUpdate(username: string, data?: Data7, options?: any) {
      return ApiApiFp(configuration).usersUpdate(username, data, options)(fetch, basePath);
    }
  };
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
  /**
   *
   * @param {string} slug
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public gamesRead(slug: string, options?: any) {
    return ApiApiFp(this.configuration).gamesRead(slug, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} tournament
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public gamesTList(tournament: string, options?: any) {
    return ApiApiFp(this.configuration).gamesTList(tournament, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {Data} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public groupsCreate(data?: Data, options?: any) {
    return ApiApiFp(this.configuration).groupsCreate(data, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} slug
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public groupsDelete(slug: string, options?: any) {
    return ApiApiFp(this.configuration).groupsDelete(slug, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public groupsList(options?: any) {
    return ApiApiFp(this.configuration).groupsList(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} slug
   * @param {Data2} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public groupsPartialUpdate(slug: string, data?: Data2, options?: any) {
    return ApiApiFp(this.configuration).groupsPartialUpdate(slug, data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {string} slug
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public groupsRead(slug: string, options?: any) {
    return ApiApiFp(this.configuration).groupsRead(slug, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} slug
   * @param {Data1} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public groupsUpdate(slug: string, data?: Data1, options?: any) {
    return ApiApiFp(this.configuration).groupsUpdate(slug, data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public leaderboardsList(options?: any) {
    return ApiApiFp(this.configuration).leaderboardsList(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} tournament
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public leaderboardsList0(tournament: string, options?: any) {
    return ApiApiFp(this.configuration).leaderboardsList0(tournament, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {Data3} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public predictionsCreate(data?: Data3, options?: any) {
    return ApiApiFp(this.configuration).predictionsCreate(data, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {number} id A unique integer value identifying this prediction.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public predictionsDelete(id: number, options?: any) {
    return ApiApiFp(this.configuration).predictionsDelete(id, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public predictionsList(options?: any) {
    return ApiApiFp(this.configuration).predictionsList(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {number} id A unique integer value identifying this prediction.
   * @param {Data5} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public predictionsPartialUpdate(id: number, data?: Data5, options?: any) {
    return ApiApiFp(this.configuration).predictionsPartialUpdate(id, data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {number} id A unique integer value identifying this prediction.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public predictionsRead(id: number, options?: any) {
    return ApiApiFp(this.configuration).predictionsRead(id, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {number} id A unique integer value identifying this prediction.
   * @param {Data4} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public predictionsUpdate(id: number, data?: Data4, options?: any) {
    return ApiApiFp(this.configuration).predictionsUpdate(id, data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public tournamentsList(options?: any) {
    return ApiApiFp(this.configuration).tournamentsList(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} slug
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public tournamentsRead(slug: string, options?: any) {
    return ApiApiFp(this.configuration).tournamentsRead(slug, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {Data6} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public usersCreate(data?: Data6, options?: any) {
    return ApiApiFp(this.configuration).usersCreate(data, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} username
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public usersDelete(username: string, options?: any) {
    return ApiApiFp(this.configuration).usersDelete(username, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public usersList(options?: any) {
    return ApiApiFp(this.configuration).usersList(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public usersMe(options?: any) {
    return ApiApiFp(this.configuration).usersMe(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} username
   * @param {Data8} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public usersPartialUpdate(username: string, data?: Data8, options?: any) {
    return ApiApiFp(this.configuration).usersPartialUpdate(username, data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {string} username
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public usersRead(username: string, options?: any) {
    return ApiApiFp(this.configuration).usersRead(username, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} username
   * @param {Data7} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public usersUpdate(username: string, data?: Data7, options?: any) {
    return ApiApiFp(this.configuration).usersUpdate(username, data, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * AuthApi - fetch parameter creator
 * @export
 */
// @ts-ignore
export const AuthApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object's key.
     * @summary Check the credentials and return the REST Token
     * @param {Data9} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginCreate(data?: Data9, options: any = {}): FetchArgs {
      const localVarPath = `/auth/login/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data9' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
     * @summary Calls Django logout method and delete the Token object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutCreate(options: any = {}): FetchArgs {
      const localVarPath = `/auth/logout/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
     * @summary Calls Django logout method and delete the Token object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutList(options: any = {}): FetchArgs {
      const localVarPath = `/auth/logout/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
     * @summary Calls Django Auth SetPasswordForm save method.
     * @param {Data10} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordChangeCreate(data?: Data10, options: any = {}): FetchArgs {
      const localVarPath = `/auth/password/change/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data10' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Password reset e-mail link is confirmed, therefore this resets the user's password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
     * @summary Password reset e-mail link is confirmed, therefore
     * @param {Data12} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetConfirmCreate(data?: Data12, options: any = {}): FetchArgs {
      const localVarPath = `/auth/password/reset/confirm/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data12' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
     * @summary Calls Django Auth PasswordResetForm save method.
     * @param {Data11} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetCreate(data?: Data11, options: any = {}): FetchArgs {
      const localVarPath = `/auth/password/reset/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data11' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {Data13} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registrationCreate(data?: Data13, options: any = {}): FetchArgs {
      const localVarPath = `/auth/registration/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data13' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {Data14} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registrationVerifyEmailCreate(data?: Data14, options: any = {}): FetchArgs {
      const localVarPath = `/auth/registration/verify-email/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data14' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @summary Reads and updates UserModel fields
     * @param {Data16} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userPartialUpdate(data?: Data16, options: any = {}): FetchArgs {
      const localVarPath = `/auth/user/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data16' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @summary Reads and updates UserModel fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userRead(options: any = {}): FetchArgs {
      const localVarPath = `/auth/user/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @summary Reads and updates UserModel fields
     * @param {Data15} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userUpdate(data?: Data15, options: any = {}): FetchArgs {
      const localVarPath = `/auth/user/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Data15' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : data || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object's key.
     * @summary Check the credentials and return the REST Token
     * @param {Data9} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginCreate(
      data?: Data9,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(configuration).loginCreate(data, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
     * @summary Calls Django logout method and delete the Token object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutCreate(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(configuration).logoutCreate(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
     * @summary Calls Django logout method and delete the Token object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(configuration).logoutList(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
     * @summary Calls Django Auth SetPasswordForm save method.
     * @param {Data10} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordChangeCreate(
      data?: Data10,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(configuration).passwordChangeCreate(
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Password reset e-mail link is confirmed, therefore this resets the user's password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
     * @summary Password reset e-mail link is confirmed, therefore
     * @param {Data12} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetConfirmCreate(
      data?: Data12,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(configuration).passwordResetConfirmCreate(
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
     * @summary Calls Django Auth PasswordResetForm save method.
     * @param {Data11} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetCreate(
      data?: Data11,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(configuration).passwordResetCreate(
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {Data13} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registrationCreate(
      data?: Data13,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(configuration).registrationCreate(
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {Data14} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registrationVerifyEmailCreate(
      data?: Data14,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(
        configuration
      ).registrationVerifyEmailCreate(data, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @summary Reads and updates UserModel fields
     * @param {Data16} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userPartialUpdate(
      data?: Data16,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(configuration).userPartialUpdate(
        data,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @summary Reads and updates UserModel fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userRead(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(configuration).userRead(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @summary Reads and updates UserModel fields
     * @param {Data15} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userUpdate(
      data?: Data15,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthApiFetchParamCreator(configuration).userUpdate(data, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object's key.
     * @summary Check the credentials and return the REST Token
     * @param {Data9} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginCreate(data?: Data9, options?: any) {
      return AuthApiFp(configuration).loginCreate(data, options)(fetch, basePath);
    },
    /**
     * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
     * @summary Calls Django logout method and delete the Token object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutCreate(options?: any) {
      return AuthApiFp(configuration).logoutCreate(options)(fetch, basePath);
    },
    /**
     * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
     * @summary Calls Django logout method and delete the Token object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutList(options?: any) {
      return AuthApiFp(configuration).logoutList(options)(fetch, basePath);
    },
    /**
     * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
     * @summary Calls Django Auth SetPasswordForm save method.
     * @param {Data10} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordChangeCreate(data?: Data10, options?: any) {
      return AuthApiFp(configuration).passwordChangeCreate(data, options)(fetch, basePath);
    },
    /**
     * Password reset e-mail link is confirmed, therefore this resets the user's password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
     * @summary Password reset e-mail link is confirmed, therefore
     * @param {Data12} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetConfirmCreate(data?: Data12, options?: any) {
      return AuthApiFp(configuration).passwordResetConfirmCreate(data, options)(fetch, basePath);
    },
    /**
     * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
     * @summary Calls Django Auth PasswordResetForm save method.
     * @param {Data11} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetCreate(data?: Data11, options?: any) {
      return AuthApiFp(configuration).passwordResetCreate(data, options)(fetch, basePath);
    },
    /**
     *
     * @param {Data13} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registrationCreate(data?: Data13, options?: any) {
      return AuthApiFp(configuration).registrationCreate(data, options)(fetch, basePath);
    },
    /**
     *
     * @param {Data14} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registrationVerifyEmailCreate(data?: Data14, options?: any) {
      return AuthApiFp(configuration).registrationVerifyEmailCreate(data, options)(fetch, basePath);
    },
    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @summary Reads and updates UserModel fields
     * @param {Data16} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userPartialUpdate(data?: Data16, options?: any) {
      return AuthApiFp(configuration).userPartialUpdate(data, options)(fetch, basePath);
    },
    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @summary Reads and updates UserModel fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userRead(options?: any) {
      return AuthApiFp(configuration).userRead(options)(fetch, basePath);
    },
    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @summary Reads and updates UserModel fields
     * @param {Data15} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userUpdate(data?: Data15, options?: any) {
      return AuthApiFp(configuration).userUpdate(data, options)(fetch, basePath);
    }
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object's key.
   * @summary Check the credentials and return the REST Token
   * @param {Data9} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public loginCreate(data?: Data9, options?: any) {
    return AuthApiFp(this.configuration).loginCreate(data, options)(this.fetch, this.basePath);
  }

  /**
   * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
   * @summary Calls Django logout method and delete the Token object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public logoutCreate(options?: any) {
    return AuthApiFp(this.configuration).logoutCreate(options)(this.fetch, this.basePath);
  }

  /**
   * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
   * @summary Calls Django logout method and delete the Token object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public logoutList(options?: any) {
    return AuthApiFp(this.configuration).logoutList(options)(this.fetch, this.basePath);
  }

  /**
   * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
   * @summary Calls Django Auth SetPasswordForm save method.
   * @param {Data10} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public passwordChangeCreate(data?: Data10, options?: any) {
    return AuthApiFp(this.configuration).passwordChangeCreate(data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Password reset e-mail link is confirmed, therefore this resets the user's password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
   * @summary Password reset e-mail link is confirmed, therefore
   * @param {Data12} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public passwordResetConfirmCreate(data?: Data12, options?: any) {
    return AuthApiFp(this.configuration).passwordResetConfirmCreate(data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
   * @summary Calls Django Auth PasswordResetForm save method.
   * @param {Data11} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public passwordResetCreate(data?: Data11, options?: any) {
    return AuthApiFp(this.configuration).passwordResetCreate(data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {Data13} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public registrationCreate(data?: Data13, options?: any) {
    return AuthApiFp(this.configuration).registrationCreate(data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {Data14} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public registrationVerifyEmailCreate(data?: Data14, options?: any) {
    return AuthApiFp(this.configuration).registrationVerifyEmailCreate(data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   * @summary Reads and updates UserModel fields
   * @param {Data16} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public userPartialUpdate(data?: Data16, options?: any) {
    return AuthApiFp(this.configuration).userPartialUpdate(data, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   * @summary Reads and updates UserModel fields
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public userRead(options?: any) {
    return AuthApiFp(this.configuration).userRead(options)(this.fetch, this.basePath);
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   * @summary Reads and updates UserModel fields
   * @param {Data15} [data]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public userUpdate(data?: Data15, options?: any) {
    return AuthApiFp(this.configuration).userUpdate(data, options)(this.fetch, this.basePath);
  }
}

/**
 * DocsApi - fetch parameter creator
 * @export
 */
// @ts-ignore
export const DocsApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(options: any = {}): FetchArgs {
      const localVarPath = `/docs/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * DocsApi - functional programming interface
 * @export
 */
export const DocsApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DocsApiFetchParamCreator(configuration).list(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * DocsApi - factory interface
 * @export
 */
export const DocsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(options?: any) {
      return DocsApiFp(configuration).list(options)(fetch, basePath);
    }
  };
};

/**
 * DocsApi - object-oriented interface
 * @export
 * @class DocsApi
 * @extends {BaseAPI}
 */
export class DocsApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocsApi
   */
  public list(options?: any) {
    return DocsApiFp(this.configuration).list(options)(this.fetch, this.basePath);
  }
}
